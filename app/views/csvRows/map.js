// Generated by CoffeeScript 1.6.3
/*

This returns an array of objects that describe a CSV
The only real behavior worth mentioning here is
*/

(function(doc) {
  var cell, clone, datetimeCount, datetimeSuffix, doublesIncluded, exportValue, isClassResult, keyId, linearIndex, linearOrder, newData, orderMap, pairsDatetime, pairsGps, pairsGrid, pairsLocation, pairsObservation, pairsSurvey, prototype, prototypes, rawIndex, result, row, subtest, subtestData, subtestIds, subtestIndex, timestamps, utils, _i, _j, _k, _len, _len1, _ref, _results;
  if (doc.collection !== "result") {
    return;
  }
  clone = function (item) { if (!item) { return item; } var types = [ Number, String, Boolean ], result; types.forEach(function(type) { if (item instanceof type) { result = type( item ); } }); if (typeof result == "undefined") { if (Object.prototype.toString.call( item ) === "[object Array]") { result = []; item.forEach(function(child, index, array) { result[index] = clone( child ); }); } else if (typeof item == "object") { if (item.nodeType && typeof item.cloneNode == "function") { var result = item.cloneNode( true ); } else if (!item.prototype) { if (item instanceof Date) { result = new Date(item); } else { result = {}; for (var i in item) { result[i] = clone( item[i] ); } } } else { if (false && item.constructor) { result = new item.constructor(); } else { result = item; } } } else { result = item; } } return result; };
  utils = require("views/lib/utils");
  exportValue = utils.exportValue;
  cell = utils.cell;
  prototypes = require("views/lib/prototypes");
  pairsGrid = prototypes.pairsGrid;
  pairsSurvey = prototypes.pairsSurvey;
  pairsDatetime = prototypes.pairsDatetime;
  pairsObservation = prototypes.pairsObservation;
  pairsGps = prototypes.pairsGps;
  pairsLocation = prototypes.pairsLocation;
  subtestData = doc.subtestData;
  isClassResult = typeof doc.klassId !== "undefined";
  if (isClassResult) {
    newData = clone(doc.subtestData);
    newData.subtestId = doc.subtestId;
    newData.time_allowed = doc.timeAllowed;
    subtestData = [
      {
        data: newData,
        prototype: doc.prototype,
        subtestId: doc.subtestId
      }
    ];
    log("klass Result: " + doc._id);
  }
  /*
  Fix doubles (temporary)
  */

  doublesIncluded = clone(subtestData);
  subtestData = [];
  subtestIds = [];
  for (_i = 0, _len = doublesIncluded.length; _i < _len; _i++) {
    subtest = doublesIncluded[_i];
    if (subtestIds.indexOf(subtest.subtestId) === -1) {
      subtestData.push(subtest);
      subtestIds.push(subtest.subtestId);
    }
  }
  result = [];
  /*
  Handle universal fields first
  */

  if (isClassResult) {
    result.push(cell("universal", "studentId", doc['studentId']));
  } else {
    result.push(cell("universal", "enumerator", doc['enumerator']));
    result.push(cell("universal", "start_time", doc['starttime'] || doc['start_time']));
    result.push(cell("universal", "order_map", (doc['order_map'] != null ? doc['order_map'].join(",") : "no_record")));
  }
  datetimeCount = 0;
  linearOrder = (function() {
    _results = [];
    for (var _j = 0, _ref = subtestData.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
    return _results;
  }).apply(this);
  orderMap = doc["order_map"] != null ? doc["order_map"] : doc["orderMap"] ? doc["orderMap"] : linearOrder;
  timestamps = [];
  for (linearIndex = _k = 0, _len1 = linearOrder.length; _k < _len1; linearIndex = ++_k) {
    rawIndex = linearOrder[linearIndex];
    row = [];
    subtestIndex = orderMap.indexOf(rawIndex);
    subtest = subtestData[subtestIndex];
    if (subtest == null) {
      log("[CSV-DEBUG] skipped empty subtest");
      log(doc);
      continue;
    }
    if (subtest.data == null) {
      log("[CSV-DEBUG] skipped subtest with null data");
      log(doc);
      continue;
    }
    prototype = subtest['prototype'];
    if (prototype === "id") {
      result.push(cell(subtest, "id", subtest.data.participant_id));
    } else if (prototype === "consent") {
      result.push(cell(subtest, "consent", subtest.data.consent));
    } else if (prototype === "complete") {
      result = result.concat([cell(subtest, "additional_comments", subtest.data.comment), cell(subtest, "end_time", subtest.data.end_time)]);
    } else if (prototype === "datetime") {
      datetimeSuffix = datetimeCount > 0 ? "_" + datetimeCount : "";
      result = result.concat(pairsDatetime(subtest, datetimeSuffix));
      datetimeCount++;
    } else if (prototype === "location") {
      result = result.concat(pairsLocation(subtest));
    } else if (prototype === "grid") {
      result = result.concat(pairsGrid(subtest, isClassResult));
    } else if (prototype === "survey") {
      result = result.concat(pairsSurvey(subtest));
    } else if (prototype === "observation") {
      result = result.concat(pairsObservation(subtest));
    } else if (prototype === "gps") {
      result = result.concat(pairsGps(subtest));
    }
    result.push(cell(subtest, "timestamp_" + linearIndex, subtest.timestamp));
  }
  keyId = isClassResult ? doc.klassId : doc._id;
  return emit(keyId, result);
});
